{"entries":[{"timestamp":1751127592980,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables>"],[1,"www.w3.org/1999/xhtml\">\n  "],[0,"<blo"]],"start1":12,"start2":12,"length1":70,"length2":37},{"diffs":[[0,"art\""],[-1," x=\"20\" y=\"20\""],[0,"></b"]],"start1":67,"start2":67,"length1":22,"length2":8},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":23,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"basic.forever(function () {\n\t\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":33,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\":"],[-1," \"*\",\n        \"servo\":"],[0," \"*\""]],"start1":131,"start2":131,"length1":30,"length2":8},{"diffs":[[0,"   \""],[-1,"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":232,"start2":232,"length1":32,"length2":31}]}]},{"timestamp":1751127624225,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"microbit-GY521\": \"github:pauldfoster/pxt-microbit-gy521#v0.0.2\""],[0,"\n   "]],"start1":157,"start2":157,"length1":82,"length2":8}]}]},{"timestamp":1751129565482,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"\n\n"],[0,"basi"]],"start1":0,"start2":0,"length1":6,"length2":4}]}]},{"timestamp":1751129582766,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"// Initialize the array to hold the values\nlet a: number[] = [];\n\nservos.P1.setAngle(180)\nservos.P0.setRange(0, 360)"],[0,"\n\nba"]],"start1":0,"start2":0,"length1":120,"length2":4}]}]},{"timestamp":1751129584842,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"];\n\n"],[-1,"let servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\nconst range = 45\n"],[1,"servos.P1.setAngle(180)"],[0,"\nservo"],[1,"s.P0"],[0,".set"],[-1,"A"],[1,"Ra"],[0,"ng"],[-1,"l"],[0,"e("],[-1,"home / 2) // b/c 360 deg\n\nlet run = false;"],[1,"0, 360)\n\nbasic.forever(function () {\n\t\n})\n"]],"start1":62,"start2":62,"length1":148,"length2":89}]}]},{"timestamp":1751133834447,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"lse;"],[-1,"\n\n\n"]],"start1":206,"start2":206,"length1":7,"length2":4}]}]},{"timestamp":1751133856555,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e;\n\n"],[-1,"// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 5) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\nfunction mkStepServo(\n    servo: servos.PinServo,\n    step: number,\n    pause: number,\n    is360: Boolean,\n    callback?: (angle: number) => void  // optional callback\n): (start: number, end: number) => void {\n    return function (start: number, end: number) {\n\n        if (is360) {\n            start /= 2\n            end /= 2\n        }\n\n        step = Math.abs(step);\n\n        if (start <= end) {\n            for (let i = start; i < end; i += step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        } else {\n            for (let i = start; i > end; i -= step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        }\n    };\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\n/**\n * Creates a scaling function that maps an input range to an output range.\n * The returned function closes over the provided ranges.\n *\n * @param inputMin - Minimum of input range.\n * @param inputMax - Maximum of input range.\n * @param outputMin - Minimum of output range.\n * @param outputMax - Maximum of output range.\n * @returns A function that scales an input number.\n */\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\nconst imuScaler = makeScaler(1024, -1024, -1, 1);\n\nlet meanAccel = 0;\n\nconst ss = mkStepServo(servo, 1, 40, true, function (angle: number) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    let a_r = degToRad(angle)\n\n    serial.writeValue(\"c\", Math.cos(a_r))\n    //serial.writeValue(\"a\", angle)\n\n    serial.writeValue(\"x\", v)\n    serial.writeValue(\"diff\", v - Math.cos(a_r))\n})\n\nlet tog = true\n\nbasic.forever(function () {\n    //meanAccel = runningAvg(input.acceleration(Dimension.X))\n    //let v = imuScaler(meanAccel);\n\n    pins.digitalWritePin(DigitalPin.P0, tog ? 0 : 1)\n    tog = !tog\n})"],[1,"\n"]],"start1":208,"start2":208,"length1":2880,"length2":5}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"vo\": \"*\""],[1,",\n        \"microbit-GY521\": \"github:pauldfoster/pxt-microbit-gy521#v0.0.2\""],[0,"\n    },\n"]],"start1":153,"start2":153,"length1":16,"length2":90}]}]},{"timestamp":1751134449582,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"on () {\n    "],[1,"//"],[0,"meanAccel = "]],"start1":2911,"start2":2911,"length1":24,"length2":26},{"diffs":[[0,"mension.X))\n    "],[1,"//"],[0,"let v = imuScale"]],"start1":2969,"start2":2969,"length1":32,"length2":34},{"diffs":[[0,"talPin.P"],[-1,"1"],[1,"0"],[0,", tog ? "]],"start1":3047,"start2":3047,"length1":17,"length2":17},{"diffs":[[0,"0 : 1)\n "],[-1,"\n"],[0,"   "],[-1," "],[0,"tog = !t"]],"start1":3064,"start2":3064,"length1":21,"length2":19},{"diffs":[[0,"g\n})"],[-1,"\n\n//while(true){\n //   pins.digitalWritePin(DigitalPin.P2, tog ? 0 : 1)\n //   tog = !tog\n//}\n"]],"start1":3084,"start2":3084,"length1":97,"length2":4}]}]},{"timestamp":1751134959897,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," tog"],[-1,"1 = true\nlet tog2"],[0," = t"]],"start1":2878,"start2":2878,"length1":25,"length2":8},{"diffs":[[0,".P1, tog"],[-1,"1"],[0," ? 0 : 1"]],"start1":3049,"start2":3049,"length1":17,"length2":16},{"diffs":[[0," tog"],[-1,"1"],[0," = !tog"],[-1,"1"],[0,"\n})\n\n"],[-1,"let count = 0;\n"],[1,"//"],[0,"while"],[-1," "],[0,"(true)"],[-1," {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n "],[1,"{\n //"],[0,"   p"]],"start1":3072,"start2":3072,"length1":149,"length2":38},{"diffs":[[0,".P2, tog"],[-1,"2"],[0," ? 0 : 1"]],"start1":3140,"start2":3140,"length1":17,"length2":16},{"diffs":[[0,": 1)"],[-1,";"],[0,"\n "],[1,"//"],[0,"   tog"],[-1,"2"],[0," = !tog"],[-1,"2\n    count++;\n    if (count >= 1000) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n"],[1,"\n//"],[0,"}\n"]],"start1":3153,"start2":3153,"length1":140,"length2":26}]}]},{"timestamp":1751135556412,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"og1\n"],[-1,"    basic.pause(1)\n"],[0,"})\n\n"]],"start1":3100,"start2":3100,"length1":27,"length2":8}]}]},{"timestamp":1751136089721,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"= true\n\n"],[-1,"\n\n"],[0,"basic.fo"]],"start1":2900,"start2":2900,"length1":18,"length2":16},{"diffs":[[0,");\n\n"],[-1,"    serial.writeValue(\"v\", v)\n    basic.pause(1)\n\n"],[0,"    "]],"start1":3027,"start2":3027,"length1":58,"length2":8},{"diffs":[[0," 0 : 1)\n"],[1," "],[0,"\n"],[-1,""],[0,"    tog1"]],"start1":3077,"start2":3077,"length1":17,"length2":18},{"diffs":[[0,"og1\n"],[1,"    basic.pause(1)\n"],[0,"})\n\n"],[-1,"\n"],[0,"let "]],"start1":3100,"start2":3100,"length1":13,"length2":31},{"diffs":[[0,"= !tog2\n"],[-1,"\n"],[0,"    coun"]],"start1":3317,"start2":3317,"length1":17,"length2":16},{"diffs":[[0," 0;\n"],[1,""],[0,"    }\n"],[-1,"\n    control.waitMicros(500)\n\n"],[0,"}\n"]],"start1":3430,"start2":3430,"length1":42,"length2":12}]}]},{"timestamp":1751136625242,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"function radToDeg(radians: number): number {\n    return radians * (180 / Math.PI);\n}\n"],[0,"func"]],"start1":647,"start2":647,"length1":93,"length2":8},{"diffs":[[0,"v\", "],[-1,"radToDeg(Math.acos(v))-90"],[1,"v"],[0,")\n  "]],"start1":3056,"start2":3056,"length1":33,"length2":9},{"diffs":[[0,"t >= 100"],[1,"0"],[0,") {\n    "]],"start1":3384,"start2":3384,"length1":16,"length2":17}]}]},{"timestamp":1751136925824,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sion.X))"],[1,"\n    let v = imuScaler(meanAccel);"],[0,"\n\n    pi"]],"start1":3351,"start2":3351,"length1":16,"length2":50}]}]},{"timestamp":1751139972452,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ccel);\n\n    "],[-1,"//"],[0,"serial.write"]],"start1":3110,"start2":3110,"length1":26,"length2":24}]}]},{"timestamp":1751139983160,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  };\n}\n\n"],[1,"\n"],[0,"input.on"]],"start1":1692,"start2":1692,"length1":16,"length2":17},{"diffs":[[0,"r {\n"],[-1,"\n        if (input < inputMin){\n            return inputMin\n        }\n\n        if ( i)\n\n"],[0,"    "]],"start1":2417,"start2":2417,"length1":96,"length2":8},{"diffs":[[0,"eanAccel);\n\n"],[1,""],[0,"    //serial"]],"start1":3106,"start2":3106,"length1":24,"length2":24},{"diffs":[[0,"90)\n"],[-1,"    serial.writeValue(\"v\", meanAccel)\n"],[0,"    "]],"start1":3170,"start2":3170,"length1":46,"length2":8}]}]},{"timestamp":1751140581767,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"}\n\n\n"],[-1,"input.onButtonPressed(Button.A, function () {\n    run = !run\n})\n"],[1,"function mkStepServo(\n    servo: servos.PinServo,\n    step: number,\n    pause: number,\n    is360: Boolean,\n    callback?: (angle: number) => void  // optional callback\n): (start: number, end: number) => void {\n    return function (start: number, end: number) {\n\n        if (is360) {\n            start /= 2\n            end /= 2\n        }\n\n        step = Math.abs(step);\n\n        if (start <= end) {\n            for (let i = start; i < end; i += step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        } else {\n            for (let i = start; i > end; i -= step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        }\n    };\n}\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\n/**\n * Creates a scaling function that maps an input range to an output range.\n * The returned function closes over the provided ranges.\n *\n * @param inputMin - Minimum of input range.\n * @param inputMax - Maximum of input range.\n * @param outputMin - Minimum of output range.\n * @param outputMax - Maximum of output range.\n * @returns A function that scales an input number.\n */"],[0,"\nfun"]],"start1":819,"start2":819,"length1":72,"length2":1329},{"diffs":[[0,"     return "],[-1,"out"],[1,"in"],[0,"putMin\n     "]],"start1":2459,"start2":2459,"length1":27,"length2":26},{"diffs":[[0," ( i"],[-1,"nput > inputMax){\n            return outputMax\n        }"],[1,")"],[0,"\n\n  "]],"start1":2501,"start2":2501,"length1":64,"length2":9},{"diffs":[[0,"ler("],[-1,"-500, 500"],[1,"1024, -1024"],[0,", -1"],[-1,"00"],[0,", 1"],[-1,"00);\n\nconst servoScaler = makeScaler(-100, 100, home-range, home+r"],[1,");\n\nlet meanAccel = 0;\n\nconst ss = mkStepServo(servo, 1, 40, true, function (angle: number) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    let a_r = degToRad(angle)\n\n    serial.writeValue(\"c\", Math.cos(a_r))\n    //serial.writeValue(\"a\", "],[0,"ang"],[1,"l"],[0,"e)"],[-1,";"],[0,"\n\n"],[-1,"let meanAccel = 0;"],[1,"    serial.writeValue(\"x\", v)\n    serial.writeValue(\"diff\", v - Math.cos(a_r))\n})\n\nlet tog1 = true\nlet tog2 = true\n\n"],[0,"\n\nba"]],"start1":2642,"start2":2642,"length1":118,"length2":442},{"diffs":[[0,"ccel);\n\n    "],[1,"//"],[0,"serial.write"]],"start1":3197,"start2":3197,"length1":24,"length2":26},{"diffs":[[0,"v\", "],[-1,"v)\n\n    let s = servoScaler(v"],[1,"radToDeg(Math.acos(v))-90"],[0,")\n  "]],"start1":3230,"start2":3230,"length1":37,"length2":33},{"diffs":[[0,"ue(\""],[-1,"s\", s)\n\n    servo.setAngle(s / 2) // b/c 360 deg\n\n\n    basic.pause(1)\n"],[1,"v\", meanAccel)\n    basic.pause(1)\n\n    pins.digitalWritePin(DigitalPin.P1, tog1 ? 0 : 1)\n\n    tog1 = !tog1"],[0,"\n})\n"]],"start1":3280,"start2":3280,"length1":78,"length2":114},{"diffs":[[0,"on.X))\n\n"],[1,"    pins.digitalWritePin(DigitalPin.P2, tog2 ? 0 : 1);\n    tog2 = !tog2\n\n"],[0,"    coun"]],"start1":3480,"start2":3480,"length1":16,"length2":89}]}]},{"timestamp":1751141391068,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0, 100, home"],[-1,"+"],[1,"-"],[0,"range, home+"]],"start1":1503,"start2":1503,"length1":25,"length2":25}]}]},{"timestamp":1751141395983,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"// Scale from the \n"],[0,"cons"]],"start1":1412,"start2":1412,"length1":27,"length2":8},{"diffs":[[0,"00, home"],[-1,"-"],[1,"+"],[0,"range, h"]],"start1":1507,"start2":1507,"length1":17,"length2":17},{"diffs":[[0,"s)\n\n"],[-1,"    if(run){\n    "],[0,"    "]],"start1":1765,"start2":1765,"length1":25,"length2":8},{"diffs":[[0,"360 deg\n"],[-1,"    }"],[0,"\n\n    ba"]],"start1":1802,"start2":1802,"length1":21,"length2":16}]}]},{"timestamp":1751141995114,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n// "],[-1,"Using the range (-1000 to 1000 ) for both input and output\n// for to make it easy to interpret\n\n// Scale from the natural IMU output ( -1024 to 1024 ) to \n// more limited range"],[1,"Scale from the "],[0,"\ncon"]],"start1":1415,"start2":1415,"length1":184,"length2":23},{"diffs":[[0,"-100"],[-1,"0"],[0,", 100"],[-1,"0"],[0,");\n\n"],[-1,"// Scale the output range to degrees for the servo\n// remember it is a 360 deg servo, but the control is for 180\n"],[0,"cons"]],"start1":1475,"start2":1475,"length1":132,"length2":17},{"diffs":[[0,"-100"],[-1,"0"],[0,", 100"],[-1,"0"],[0,", "],[-1,"("],[0,"home"]],"start1":1519,"start2":1519,"length1":18,"length2":15},{"diffs":[[0,"ange"],[-1,")/2"],[0,", "],[-1,"("],[0,"home"]],"start1":1536,"start2":1536,"length1":14,"length2":10},{"diffs":[[0,"nge)"],[-1,"/2)"],[0,";\n\nl"]],"start1":1549,"start2":1549,"length1":11,"length2":8},{"diffs":[[0,"Angle(s "],[-1,") "],[1,"/ 2) // b/c 360 deg"],[0,"\n    }\n\n"]],"start1":1818,"start2":1818,"length1":18,"length2":35},{"diffs":[[0,"1)\n\n})\n\n"],[1,"\n"],[0,"let coun"]],"start1":1869,"start2":1869,"length1":16,"length2":17}]}]},{"timestamp":1751142171656,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  };\n}\n\n"],[-1,"\n\n"],[0,"// Using"]],"start1":1408,"start2":1408,"length1":18,"length2":16}]}]},{"timestamp":1751143192031,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n}\n\n"],[-1,"/**\n * Creates a PID controller function.\n * \n * @param {number} kp - Proportional gain\n * @param {number} ki - Integral gain\n * @param {number} kd - Derivative gain\n * @returns {(input: number) => number} - The PID function that takes the current error and returns the control output\n */\nfunction makePID(kp: number, ki: number, kd: number) {\n    let integral = 0;\n    let lastError = 0;\n    let lastTime = control.millis();\n\n    return function (error: number) {\n        const now = control.millis();\n        const dtMs = now - lastTime;\n        const dt = dtMs / 1000; // Convert ms to seconds\n\n        // Defensive: avoid division by zero\n        const safeDt = dt > 0 ? dt : 1e-3;\n\n        integral += error * safeDt;\n        const derivative = (error - lastError) / safeDt;\n\n        const output = kp * error + ki * integral + kd * derivative;\n\n        lastError = error;\n        lastTime = now;\n\n        return output;\n    };\n}"],[0,"\n\n//"]],"start1":1412,"start2":1412,"length1":942,"length2":8}]}]},{"timestamp":1751143193560,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"put\n */\n"],[-1,"\n"],[0,"function"]],"start1":1697,"start2":1697,"length1":17,"length2":16},{"diffs":[[0,"\n}\n\n"],[-1,"\nconst kp = 0.6;   // Proportional gain (max ~±800 output for full error)\nconst ki = 0.05; // Very small integral gain to prevent windup\nconst kd = 0.05;  // Small derivative gain to avoid spikes\n\n\nconst pid = makePID(kp, ki, kd);\n\n"],[0,"// U"]],"start1":2348,"start2":2348,"length1":240,"length2":8},{"diffs":[[0,"    let "],[-1,"i"],[1,"v "],[0,"= imuSca"]],"start1":2886,"start2":2886,"length1":17,"length2":18},{"diffs":[[0,"ue(\""],[-1,"i\", i)\n\n    let o = pid(i)\n    serial.writeValue(\"o\", o"],[1,"v\", v"],[0,")\n\n "]],"start1":2940,"start2":2940,"length1":63,"length2":13},{"diffs":[[0,"oScaler("],[-1,"o"],[1,"v"],[0,")\n    se"]],"start1":2968,"start2":2968,"length1":17,"length2":17},{"diffs":[[0,"s)\n\n"],[-1,"   \n"],[0,"    "]],"start1":3006,"start2":3006,"length1":12,"length2":8}]}]},{"timestamp":1751143751868,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," kd:"],[-1," number, alpha:"],[0," num"]],"start1":1746,"start2":1746,"length1":23,"length2":8},{"diffs":[[0,"eDt;"],[-1,"\n\n        const filteredError = alpha * error + (1 - alpha) * lastError;\n\n       "],[0,"\n   "]],"start1":2135,"start2":2135,"length1":89,"length2":8},{"diffs":[[0," = ("],[-1,"filteredE"],[1,"e"],[0,"rror"]],"start1":2164,"start2":2164,"length1":17,"length2":9},{"diffs":[[0,"rror) / "],[-1,"d"],[1,"safeD"],[0,"t;\n\n    "]],"start1":2181,"start2":2181,"length1":17,"length2":21},{"diffs":[[0,"p = "],[-1,"1"],[1,"0.6"],[0,";   "],[-1,"\nconst ki = 0\nconst kd = 0.2\nconst alpha = 0.4"],[1,"// Proportional gain (max ~±800 output for full error)\nconst ki = 0.05; // Very small integral gain to prevent windup\nconst kd = 0.05;  // Small derivative gain to avoid spikes"],[0,"\n\n\nc"]],"start1":2361,"start2":2361,"length1":59,"length2":191},{"diffs":[[0,", kd"],[-1,", alpha"],[0,");\n\n"]],"start1":2577,"start2":2577,"length1":15,"length2":8},{"diffs":[[0,") {\n"],[-1,"   \n\n    basic.pause(1)\n\n})\n\nlet count = 0;\nwhile (true) {\n\n"],[0,"    "]],"start1":3055,"start2":3055,"length1":68,"length2":8},{"diffs":[[0,"   let i"],[-1," "],[0,"= imuSca"]],"start1":3120,"start2":3120,"length1":17,"length2":16},{"diffs":[[0,"s)\n\n"],[1,"   "],[0,"\n    if"],[-1," "],[0,"(run)"],[-1," "],[0,"{\n  "]],"start1":3288,"start2":3288,"length1":22,"length2":23},{"diffs":[[0,"le(s"],[-1,")"],[1," ) "],[0,"\n    }\n\n"],[1,"    basic.pause(1)\n\n})\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n\n"],[0,"    "]],"start1":3329,"start2":3329,"length1":17,"length2":135}]}]},{"timestamp":1751144335019,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"me = 180"],[1,"\nconst range = 45"],[0,"\n\nservo."]],"start1":126,"start2":126,"length1":16,"length2":33},{"diffs":[[0,"t run = "],[-1,"tru"],[1,"fals"],[0,"e;\n\n// F"]],"start1":196,"start2":196,"length1":19,"length2":20},{"diffs":[[0,"umber = "],[-1,"10"],[1,"5"],[0,") {\n    "]],"start1":312,"start2":312,"length1":18,"length2":17},{"diffs":[[0,"}\n\n\n"],[-1,"const range = 60\n\n"],[0,"cons"]],"start1":2450,"start2":2450,"length1":26,"length2":8},{"diffs":[[0," = 0"],[-1,".04"],[0,"\ncon"]],"start1":2479,"start2":2479,"length1":11,"length2":8},{"diffs":[[0,"= 0."],[-1,"06"],[1,"2"],[0,"\ncon"]],"start1":2493,"start2":2493,"length1":10,"length2":9},{"diffs":[[0,"a = "],[-1,".3"],[1,"0.4\n"],[0,"\n\nco"]],"start1":2509,"start2":2509,"length1":10,"length2":12}]}]},{"timestamp":1751144916374,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e = "],[-1,"75"],[1,"60"],[0,"\n\nco"]],"start1":2447,"start2":2447,"length1":10,"length2":10},{"diffs":[[0,"nst ki = 0.0"],[-1,"0"],[1,"4"],[0,"\nconst kd = "]],"start1":2474,"start2":2474,"length1":25,"length2":25},{"diffs":[[0,"kd = 0.0"],[-1,"0"],[1,"6"],[0,"\nconst a"]],"start1":2494,"start2":2494,"length1":17,"length2":17},{"diffs":[[0,"er(-"],[-1,"7"],[1,"5"],[0,"00, "],[-1,"7"],[1,"5"],[0,"00, "]],"start1":2769,"start2":2769,"length1":14,"length2":14}]}]},{"timestamp":1751145315086,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e = "],[-1,"40"],[1,"75"],[0,"\n\nco"]],"start1":2447,"start2":2447,"length1":10,"length2":10},{"diffs":[[0,"p = "],[-1,".7"],[1,"1"],[0,";   "]],"start1":2462,"start2":2462,"length1":10,"length2":9},{"diffs":[[0,"l = 0;\n\n"],[1,"basic.forever(function () {\n   \n\n    basic.pause(1)\n\n})\n"],[0,"\nlet cou"]],"start1":3001,"start2":3001,"length1":16,"length2":72}]}]},{"timestamp":1751145881615,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"n = "],[-1,"fals"],[1,"tru"],[0,"e;\n\n"]],"start1":183,"start2":183,"length1":12,"length2":11},{"diffs":[[0,"umber = "],[-1,"3"],[1,"10"],[0,") {\n    "]],"start1":294,"start2":294,"length1":17,"length2":18},{"diffs":[[0,"e = "],[-1,"75"],[1,"40"],[0,"\n\nco"]],"start1":2447,"start2":2447,"length1":10,"length2":10},{"diffs":[[0,"kd = 0.0"],[-1,"2"],[1,"0"],[0,"\nconst a"]],"start1":2495,"start2":2495,"length1":17,"length2":17},{"diffs":[[0,"er(-"],[-1,"550, 55"],[1,"700, 70"],[0,"0, -"]],"start1":2770,"start2":2770,"length1":15,"length2":15},{"diffs":[[0,");\n\n"],[-1,"    serial.writeValue(\"a\", meanAccel)\n"],[0,"    "]],"start1":3133,"start2":3133,"length1":46,"length2":8}]}]},{"timestamp":1751146408221,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"nputMin)"],[-1," "],[0,"{\n      "]],"start1":1168,"start2":1168,"length1":17,"length2":16},{"diffs":[[0,"        if ("],[1," "],[0,"input > inpu"]],"start1":1218,"start2":1218,"length1":24,"length2":25},{"diffs":[[0,"nputMax)"],[-1," "],[0,"{\n      "]],"start1":1240,"start2":1240,"length1":17,"length2":16},{"diffs":[[0,"Error;\n\n"],[1,"       "],[0,"\n       "]],"start1":2203,"start2":2203,"length1":16,"length2":23},{"diffs":[[0,"\n\nconst "],[-1,"servo_"],[0,"range = "]],"start1":2435,"start2":2435,"length1":22,"length2":16},{"diffs":[[0," 75\n"],[-1,"const mass_range = 25\n\n"],[0,"\ncon"]],"start1":2450,"start2":2450,"length1":31,"length2":8},{"diffs":[[0,"p = "],[-1,"-"],[0,".7;"],[1,"   "],[0,"\ncon"]],"start1":2462,"start2":2462,"length1":12,"length2":14},{"diffs":[[0,"d range\n"],[-1,"//"],[0,"const im"]],"start1":2736,"start2":2736,"length1":18,"length2":16},{"diffs":[[0,"er(-"],[-1,"mass_range, mass_range, (home - servo_"],[1,"1000, 1000, (home-"],[0,"range)"],[-1," / "],[1,"/"],[0,"2, (home"],[-1," + servo_"],[1,"+"],[0,"range)"],[-1," / "],[1,"/"],[0,"2);\n"]],"start1":2940,"start2":2940,"length1":81,"length2":49},{"diffs":[[0,"let "],[-1,"angle = radToDeg(Math.asin(meanAccel / 1024))\n\n\n    serial.writeValue(\"a\", angle"],[1,"i = imuScaler(meanAccel);\n\n    serial.writeValue(\"a\", meanAccel)\n    serial.writeValue(\"i\", i"],[0,")\n\n "]],"start1":3106,"start2":3106,"length1":88,"length2":101},{"diffs":[[0,"pid("],[-1,"angle"],[1,"i"],[0,")\n  "]],"start1":3218,"start2":3218,"length1":13,"length2":9}]}]},{"timestamp":1751146922775,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"umber = "],[-1,"4"],[1,"3"],[0,") {\n    "]],"start1":295,"start2":295,"length1":17,"length2":17},{"diffs":[[0,"        "],[-1,"le"],[1,"cons"],[0,"t filter"]],"start1":2140,"start2":2140,"length1":18,"length2":20},{"diffs":[[0,"r;\n\n"],[-1,"        if (Number.isNaN(filteredError)){\n            filteredError = error\n\n        }\n"],[0,"\n   "]],"start1":2208,"start2":2208,"length1":95,"length2":8},{"diffs":[[0,"range = "],[-1,"60"],[1,"25"],[0,"\n\n\nconst"]],"start1":2465,"start2":2465,"length1":18,"length2":18},{"diffs":[[0,"p = "],[-1,".1"],[1,"-.7"],[0,";\nco"]],"start1":2485,"start2":2485,"length1":10,"length2":11},{"diffs":[[0,"nst kd = 0.0"],[-1,"0"],[1,"2"],[0,"\nconst alpha"]],"start1":2512,"start2":2512,"length1":25,"length2":25},{"diffs":[[0,"1024))\n\n"],[1,"\n"],[0,"    seri"]],"start1":3204,"start2":3204,"length1":16,"length2":17},{"diffs":[[0,"(o)\n"],[-1,"    if (!Number.isNaN(s)){\n    "],[0,"    "]],"start1":3325,"start2":3325,"length1":39,"length2":8},{"diffs":[[0,"\"s\", s)\n"],[1,"\n\n"],[-1,"    "],[0,"    if ("]],"start1":3351,"start2":3351,"length1":20,"length2":18},{"diffs":[[0,"        "],[-1,"  "],[-1,"  "],[0,"servo.se"]],"start1":3376,"start2":3376,"length1":20,"length2":16},{"diffs":[[0,"ngle(s)\n"],[-1,"        }\n"],[0,"    }\n\n "]],"start1":3394,"start2":3394,"length1":26,"length2":16}]}]},{"timestamp":1751147488495,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ds\n\n"],[-1,"        if(Number.isNaN(error)){\n            error = lastError\n        }\n\n\n"],[0,"    "]],"start1":2010,"start2":2010,"length1":83,"length2":8},{"diffs":[[0,"st kp = "],[-1,"-3"],[1,".1"],[0,";\nconst "]],"start1":2566,"start2":2566,"length1":18,"length2":18}]}]},{"timestamp":1751148061545,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"vos.P1\n\n"],[1,"// This is a 360degree servo\nconst home = 180\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = false;\n"],[0,"\n// Func"]],"start1":81,"start2":81,"length1":16,"length2":121},{"diffs":[[0,"\n}\n\n"],[-1,"// This is a 360degree servo\nconst home = 180\n"],[0,"\ncon"]],"start1":2586,"start2":2586,"length1":54,"length2":8},{"diffs":[[0,"p = "],[-1,"1.0"],[1,"-3"],[0,";\nco"]],"start1":2645,"start2":2645,"length1":11,"length2":10},{"diffs":[[0,"st k"],[-1,"d"],[1,"i"],[0," = 0."],[-1,"5"],[1,"0"],[0,"0\nco"]],"start1":2656,"start2":2656,"length1":15,"length2":15},{"diffs":[[0,"st k"],[-1,"i"],[1,"d"],[0," = 0.00\n"],[-1,"\n"],[0,"cons"]],"start1":2672,"start2":2672,"length1":18,"length2":17},{"diffs":[[0,"el = 0;\n"],[1,"\n\n"],[0,"let coun"]],"start1":3215,"start2":3215,"length1":16,"length2":18},{"diffs":[[0,"= 0;"],[-1,"\n\nlet run = true;\n\n"],[0,"\nwhi"]],"start1":3235,"start2":3235,"length1":27,"length2":8},{"diffs":[[0,"    let "],[-1,"mass_"],[0,"angle = "]],"start1":3316,"start2":3316,"length1":21,"length2":16},{"diffs":[[0,"ue(\"a\", "],[-1,"mass_"],[0,"angle)\n\n"]],"start1":3390,"start2":3390,"length1":21,"length2":16},{"diffs":[[0,"o = pid("],[-1,"mass_"],[0,"angle)\n "]],"start1":3414,"start2":3414,"length1":21,"length2":16},{"diffs":[[0,"e(s)"],[-1," // div 2 handled by scaler\n        } else {\n            servo.setAngle(home / 2) // b/c 360 deg\n\n        }\n    }\n\n   "],[1,"\n        }\n    }\n\n    count++;\n    if (count >= 100) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n\n    control.waitMicros(500)"],[0,"\n\n}\n"]],"start1":3592,"start2":3592,"length1":126,"length2":168}]}]},{"timestamp":1751148745637,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n\n   "],[-1," "],[0,"\n\n}\n"]],"start1":3681,"start2":3681,"length1":13,"length2":12}]}]},{"timestamp":1751148753491,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"p = "],[1,"1"],[0,".0"],[-1,"4"],[0,";\nco"]],"start1":2586,"start2":2586,"length1":11,"length2":11},{"diffs":[[0," kd = 0."],[-1,"1"],[1,"50"],[0,"\nconst k"]],"start1":2600,"start2":2600,"length1":17,"length2":18},{"diffs":[[0,"for 180\n"],[-1,"//"],[0,"const se"]],"start1":3029,"start2":3029,"length1":18,"length2":16},{"diffs":[[0,");\n\n"],[-1,"// This configuration just provides limits\nconst servoScaler = makeScaler((home - servo_range) / 2, (home + servo_range) / 2, (home - servo_range) / 2, (home + servo_range) / 2);\n\n"],[0,"let "]],"start1":3143,"start2":3143,"length1":188,"length2":8},{"diffs":[[0,"e;\n\n"],[-1,"let servo_angle = home\n"],[0,"\nwhi"]],"start1":3195,"start2":3195,"length1":31,"length2":8},{"diffs":[[0,"o)\n\n"],[-1,"    servo_angle += o\n\n"],[0,"    "]],"start1":3431,"start2":3431,"length1":30,"length2":8},{"diffs":[[0,"ler("],[-1,"servo_angle"],[1,"o"],[0,")\n  "]],"start1":3455,"start2":3455,"length1":19,"length2":9},{"diffs":[[0,"\n   "],[1," "],[-1,"if(count-- == 0){\n       count = 1000;\n       basic.pause(1)\n   }"],[0,"\n\n}\n"]],"start1":3685,"start2":3685,"length1":73,"length2":9}]}]},{"timestamp":1751149353319,"editorVersion":"7.0.61","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":114}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t kp = ."],[-1,"5"],[1,"04"],[0,";\nconst "]],"start1":2583,"start2":2583,"length1":17,"length2":18},{"diffs":[[0," kd = 0."],[-1,"04"],[1,"1"],[0,"\nconst k"]],"start1":2600,"start2":2600,"length1":18,"length2":17}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":249,"start2":249,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1751127592979,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1751129565478,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"basic.forever(function () {\n\t\n})\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751133834447,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nservos.P1.setAngle(180)\nservos.P0.setRange(0, 360)\n\nbasic.forever(function () {\n\t\n})\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\",\n        \"microbit-GY521\": \"github:pauldfoster/pxt-microbit-gy521#v0.0.2\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751135841115,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nlet servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\nconst range = 45\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = false;\n\n// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 5) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\nfunction mkStepServo(\n    servo: servos.PinServo,\n    step: number,\n    pause: number,\n    is360: Boolean,\n    callback?: (angle: number) => void  // optional callback\n): (start: number, end: number) => void {\n    return function (start: number, end: number) {\n\n        if (is360) {\n            start /= 2\n            end /= 2\n        }\n\n        step = Math.abs(step);\n\n        if (start <= end) {\n            for (let i = start; i < end; i += step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        } else {\n            for (let i = start; i > end; i -= step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        }\n    };\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\n/**\n * Creates a scaling function that maps an input range to an output range.\n * The returned function closes over the provided ranges.\n *\n * @param inputMin - Minimum of input range.\n * @param inputMax - Maximum of input range.\n * @param outputMin - Minimum of output range.\n * @param outputMax - Maximum of output range.\n * @returns A function that scales an input number.\n */\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\nconst imuScaler = makeScaler(1024, -1024, -1, 1);\n\nlet meanAccel = 0;\n\nconst ss = mkStepServo(servo, 1, 40, true, function (angle: number) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    let a_r = degToRad(angle)\n\n    serial.writeValue(\"c\", Math.cos(a_r))\n    //serial.writeValue(\"a\", angle)\n\n    serial.writeValue(\"x\", v)\n    serial.writeValue(\"diff\", v - Math.cos(a_r))\n})\n\nlet tog1 = true\nlet tog2 = true\n\nbasic.forever(function () {\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    pins.digitalWritePin(DigitalPin.P1, tog1 ? 0 : 1)\n \n    tog1 = !tog1\n})\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    pins.digitalWritePin(DigitalPin.P2, tog2 ? 0 : 1);\n    tog2 = !tog2\n    count++;\n    if (count >= 1000) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751139972452,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nlet servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\nconst range = 45\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = false;\n\n// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 5) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction radToDeg(radians: number): number {\n    return radians * (180 / Math.PI);\n}\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\nfunction mkStepServo(\n    servo: servos.PinServo,\n    step: number,\n    pause: number,\n    is360: Boolean,\n    callback?: (angle: number) => void  // optional callback\n): (start: number, end: number) => void {\n    return function (start: number, end: number) {\n\n        if (is360) {\n            start /= 2\n            end /= 2\n        }\n\n        step = Math.abs(step);\n\n        if (start <= end) {\n            for (let i = start; i < end; i += step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        } else {\n            for (let i = start; i > end; i -= step) {\n                servo.setAngle(i);\n                basic.pause(pause)\n                if (callback) {\n                    callback(i);\n                }\n            }\n        }\n    };\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\n/**\n * Creates a scaling function that maps an input range to an output range.\n * The returned function closes over the provided ranges.\n *\n * @param inputMin - Minimum of input range.\n * @param inputMax - Maximum of input range.\n * @param outputMin - Minimum of output range.\n * @param outputMax - Maximum of output range.\n * @returns A function that scales an input number.\n */\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\nconst imuScaler = makeScaler(1024, -1024, -1, 1);\n\nlet meanAccel = 0;\n\nconst ss = mkStepServo(servo, 1, 40, true, function (angle: number) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    let a_r = degToRad(angle)\n\n    serial.writeValue(\"c\", Math.cos(a_r))\n    //serial.writeValue(\"a\", angle)\n\n    serial.writeValue(\"x\", v)\n    serial.writeValue(\"diff\", v - Math.cos(a_r))\n})\n\nlet tog1 = true\nlet tog2 = true\n\n\n\nbasic.forever(function () {\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    serial.writeValue(\"v\", radToDeg(Math.acos(v))-90)\n    basic.pause(1)\n\n    pins.digitalWritePin(DigitalPin.P1, tog1 ? 0 : 1)\n\n    tog1 = !tog1\n})\n\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    pins.digitalWritePin(DigitalPin.P2, tog2 ? 0 : 1);\n    tog2 = !tog2\n\n    count++;\n    if (count >= 100) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n\n    control.waitMicros(500)\n\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751141939229,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nlet servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\nconst range = 45\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = false;\n\n// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 5) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction radToDeg(radians: number): number {\n    return radians * (180 / Math.PI);\n}\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n\n        if (input < inputMin){\n            return outputMin\n        }\n\n        if ( input > inputMax){\n            return outputMax\n        }\n\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\nconst imuScaler = makeScaler(-500, 500, -100, 100);\n\nconst servoScaler = makeScaler(-100, 100, home-range, home+range);\n\nlet meanAccel = 0;\n\nbasic.forever(function () {\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let v = imuScaler(meanAccel);\n\n    serial.writeValue(\"v\", v)\n\n    let s = servoScaler(v)\n    serial.writeValue(\"s\", s)\n\n    servo.setAngle(s / 2) // b/c 360 deg\n\n\n    basic.pause(1)\n\n})\n\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n\n    count++;\n    if (count >= 100) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n\n    control.waitMicros(500)\n\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751143742540,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nlet servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\nconst range = 45\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = false;\n\n// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 5) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction radToDeg(radians: number): number {\n    return radians * (180 / Math.PI);\n}\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n\n        if (input < inputMin){\n            return outputMin\n        }\n\n        if ( input > inputMax){\n            return outputMax\n        }\n\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\n/**\n * Creates a PID controller function.\n * \n * @param {number} kp - Proportional gain\n * @param {number} ki - Integral gain\n * @param {number} kd - Derivative gain\n * @returns {(input: number) => number} - The PID function that takes the current error and returns the control output\n */\n\nfunction makePID(kp: number, ki: number, kd: number) {\n    let integral = 0;\n    let lastError = 0;\n    let lastTime = control.millis();\n\n    return function (error: number) {\n        const now = control.millis();\n        const dtMs = now - lastTime;\n        const dt = dtMs / 1000; // Convert ms to seconds\n\n        // Defensive: avoid division by zero\n        const safeDt = dt > 0 ? dt : 1e-3;\n\n        integral += error * safeDt;\n        const derivative = (error - lastError) / safeDt;\n\n        const output = kp * error + ki * integral + kd * derivative;\n\n        lastError = error;\n        lastTime = now;\n\n        return output;\n    };\n}\n\n\nconst kp = 0.8;   // Proportional gain (max ~±800 output for full error)\nconst ki = 0.005; // Very small integral gain to prevent windup\nconst kd = 0.05;  // Small derivative gain to avoid spikes\n\n\nconst pid = makePID(kp, ki, kd);\n\n// Using the range (-1000 to 1000 ) for both input and output\n// for to make it easy to interpret\n\n// Scale from the natural IMU output ( -1024 to 1024 ) to \n// more limited range\nconst imuScaler = makeScaler(-500, 500, -1000, 1000);\n\n// Scale the output range to degrees for the servo\n// remember it is a 360 deg servo, but the control is for 180\nconst servoScaler = makeScaler(-1000, 1000, (home-range)/2, (home+range)/2);\n\nlet meanAccel = 0;\n\nbasic.forever(function () {\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let i= imuScaler(meanAccel);\n\n    serial.writeValue(\"i\", i)\n\n    let o = pid(i)\n    serial.writeValue(\"o\", o)\n\n    let s = servoScaler(o)\n    serial.writeValue(\"s\", s)\n\n   \n    if(run){\n        servo.setAngle(s ) \n    }\n\n    basic.pause(1)\n\n})\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n\n    count++;\n    if (count >= 100) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n\n    control.waitMicros(500)\n\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751145714984,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nlet servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = true;\n\n// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 10) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction radToDeg(radians: number): number {\n    return radians * (180 / Math.PI);\n}\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n\n        if (input < inputMin){\n            return outputMin\n        }\n\n        if ( input > inputMax){\n            return outputMax\n        }\n\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\n/**\n * Creates a PID controller function.\n * \n * @param {number} kp - Proportional gain\n * @param {number} ki - Integral gain\n * @param {number} kd - Derivative gain\n * @returns {(input: number) => number} - The PID function that takes the current error and returns the control output\n */\n\nfunction makePID(kp: number, ki: number, kd: number, alpha: number) {\n    let integral = 0;\n    let lastError = 0;\n    let lastTime = control.millis();\n\n    return function (error: number) {\n        const now = control.millis();\n        const dtMs = now - lastTime;\n        const dt = dtMs / 1000; // Convert ms to seconds\n\n        // Defensive: avoid division by zero\n        const safeDt = dt > 0 ? dt : 1e-3;\n\n        integral += error * safeDt;\n\n        const filteredError = alpha * error + (1 - alpha) * lastError;\n\n       \n        const derivative = (filteredError - lastError) / dt;\n\n        const output = kp * error + ki * integral + kd * derivative;\n\n        lastError = error;\n        lastTime = now;\n\n        return output;\n    };\n}\n\n\nconst range = 75\n\nconst kp = 1;   \nconst ki = 0.00\nconst kd = 0.00\nconst alpha = .3\n\nconst pid = makePID(kp, ki, kd, alpha);\n\n// Using the range (-1000 to 1000 ) for both input and output\n// for to make it easy to interpret\n\n// Scale from the natural IMU output ( -1024 to 1024 ) to \n// more limited range\nconst imuScaler = makeScaler(-700, 700, -1000, 1000);\n\n// Scale the output range to degrees for the servo\n// remember it is a 360 deg servo, but the control is for 180\nconst servoScaler = makeScaler(-1000, 1000, (home-range)/2, (home+range)/2);\n\nlet meanAccel = 0;\n\nbasic.forever(function () {\n   \n\n    basic.pause(1)\n\n})\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let i = imuScaler(meanAccel);\n\n    serial.writeValue(\"i\", i)\n\n    let o = pid(i)\n    serial.writeValue(\"o\", o)\n\n    let s = servoScaler(o)\n    serial.writeValue(\"s\", s)\n\n\n    if (run) {\n        servo.setAngle(s)\n    }\n\n    count++;\n    if (count >= 100) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n\n    control.waitMicros(500)\n\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1751147700388,"editorVersion":"7.0.61","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"// Initialize the array to hold the values\nlet a: number[] = [];\n\nlet servo = servos.P1\n\n// This is a 360degree servo\nconst home = 180\n\nservo.setAngle(home / 2) // b/c 360 deg\n\nlet run = false;\n\n// Function to add a new value and calculate the running average\nfunction runningAvg(x: number, l: number = 4) {\n    // Add the new value to the end\n    a.push(x);\n\n    if (a.length > l) {\n        a.shift();\n    }\n\n    // Calculate the sum\n    let sum = 0;\n    for (let i = 0; i < a.length; i++) {\n        sum += a[i];\n    }\n\n    // Calculate the average\n    let average = sum / a.length;\n\n    // Return the average\n    return average;\n}\n\nfunction radToDeg(radians: number): number {\n    return radians * (180 / Math.PI);\n}\nfunction degToRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n}\n\n\ninput.onButtonPressed(Button.A, function () {\n    run = !run\n})\n\nfunction makeScaler(\n    inputMin: number,\n    inputMax: number,\n    outputMin: number,\n    outputMax: number\n): (input: number) => number {\n    // This inner function will have access to inputMin, inputMax, outputMin, outputMax\n    return function (input: number): number {\n\n        if (input < inputMin) {\n            return outputMin\n        }\n\n        if (input > inputMax) {\n            return outputMax\n        }\n\n        return ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin;\n    };\n}\n\n/**\n * Creates a PID controller function.\n * \n * @param {number} kp - Proportional gain\n * @param {number} ki - Integral gain\n * @param {number} kd - Derivative gain\n * @returns {(input: number) => number} - The PID function that takes the current error and returns the control output\n */\n\nfunction makePID(kp: number, ki: number, kd: number, alpha: number) {\n    let integral = 0;\n    let lastError = 0;\n    let lastTime = control.millis();\n\n    return function (error: number) {\n        const now = control.millis();\n        const dtMs = now - lastTime;\n        const dt = dtMs / 1000; // Convert ms to seconds\n\n        // Defensive: avoid division by zero\n        const safeDt = dt > 0 ? dt : 1e-3;\n\n        integral += error * safeDt;\n\n        let filteredError = alpha * error + (1 - alpha) * lastError;\n\n        if (Number.isNaN(filteredError)){\n            filteredError = error\n\n        }\n\n        const derivative = (filteredError - lastError) / dt;\n\n        const output = kp * error + ki * integral + kd * derivative;\n\n        lastError = error;\n        lastTime = now;\n\n        return output;\n    };\n}\n\n\nconst servo_range = 75\nconst mass_range = 60\n\n\nconst kp = .1;\nconst ki = 0.00\nconst kd = 0.00\nconst alpha = .3\n\nconst pid = makePID(kp, ki, kd, alpha);\n\n// Using the range (-1000 to 1000 ) for both input and output\n// for to make it easy to interpret\n\n// Scale from the natural IMU output ( -1024 to 1024 ) to \n// more limited range\n//const imuScaler = makeScaler(-550, 550, -1000, 1000);\n\n// Scale the output range to degrees for the servo\n// remember it is a 360 deg servo, but the control is for 180\nconst servoScaler = makeScaler(-mass_range, mass_range, (home - servo_range) / 2, (home + servo_range) / 2);\n\nlet meanAccel = 0;\n\n\nlet count = 0;\nwhile (true) {\n\n    meanAccel = runningAvg(input.acceleration(Dimension.X))\n    let angle = radToDeg(Math.asin(meanAccel / 1024))\n\n    serial.writeValue(\"a\", angle)\n\n    let o = pid(angle)\n    serial.writeValue(\"o\", o)\n\n    let s = servoScaler(o)\n    if (!Number.isNaN(s)){\n        serial.writeValue(\"s\", s)\n        if (run) {\n            servo.setAngle(s)\n        }\n    }\n\n    count++;\n    if (count >= 100) {\n        basic.pause(1); // yield every 1000 toggles\n        count = 0;\n    }\n\n    control.waitMicros(500)\n\n}\n","README.md":"","pxt.json":"{\n    \"name\": \"Balancer\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1751149461147}